// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from 'sonner';
import { v4 as uuidv4 } from 'uuid';
import { errorHandler } from '@/services/ErrorHandlingService';
import { debounce } from 'lodash';

const SUPABASE_URL = "https://yfufpcxkerovnijhodrr.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlmdWZwY3hrZXJvdm5pamhvZHJyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIyNjI3ODYsImV4cCI6MjA1NzgzODc4Nn0.1x7WAfVIvlm-KPy2q4eFylaVtdc5_ZJmlis5AMJ-Izc";

// Store connection status
let isSupabaseConnected = false;
let connectionAttempts = 0;
const MAX_CONNECTION_ATTEMPTS = 5;

// Cache for tracking recent requests to prevent duplicates
const requestCache = new Map<string, {
  timestamp: number; 
  inProgress: boolean; 
  response: Record<string, unknown> | null;
}>();
const REQUEST_CACHE_TTL = 5000; // Increase TTL from 2 seconds to 5 seconds for cache entries

// Queue for storing operations when offline
const offlineQueue: { 
  operation: string; 
  callback: () => Promise<void>; 
}[] = [];

// Periodically clean up the request cache
setInterval(() => {
  const now = Date.now();
  for (const [key, value] of requestCache.entries()) {
    if (now - value.timestamp > REQUEST_CACHE_TTL) {
      requestCache.delete(key);
    }
  }
}, 10000);

// Debounced log function to prevent console spam
const debouncedLog = debounce((message: string) => {
  console.log(message);
}, 1000, { leading: true, trailing: false });

// Create a supabase client with auto-refresh and retries
export const supabase = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
    },
    global: {
      fetch: async (...args: [RequestInfo | URL, RequestInit?]): Promise<Response> => {
        const [url, options] = args;
        
        // Create a cache key based on the request
        const cacheKey = `${options?.method || 'GET'}-${url.toString()}`;
        const isReadOperation = !options?.method || options?.method === 'GET';
        const isWriteOperation = options?.method === 'POST' || options?.method === 'PUT' || options?.method === 'PATCH';
        
        // This is a new request, check if there's a completed request for the same URL
        const cachedRequest = requestCache.get(cacheKey);
        if (cachedRequest) {
          
          // If there's already a request in progress, handle accordingly
          if (cachedRequest.inProgress) {
            // Generally, we don't want duplicate simultaneous requests
            // Different behaviors based on request type
            if (isReadOperation) {
              // For read operations, we can queue this request after the existing one
              debouncedLog(`Skipping duplicate Supabase request to: ${url}`);
              
              // Return a pending promise for the duplicate request
              return new Promise<Response>((resolve, reject) => {
                // This request will be handled by the original request
                setTimeout(() => {
                  reject(new Error('Duplicate request cancelled'));
                }, 100);
              });
            }
          }
          
          // If request was recently completed (but not in progress), we have a few options:
          // 1. For GET requests, we could consider allowing it after a certain time threshold
          // 2. For mutation requests (POST/PUT/DELETE), we should be more careful
          const now = Date.now();
          const timeSinceRequest = now - cachedRequest.timestamp;
          
          // More lenient approach for GET requests to frequently accessed tables
          const frequentlyAccessedTables = ['calls', 'call_transcripts', 'keyword_trends', 'sentiment_trends'];
          const isFrequentlyAccessedTable = frequentlyAccessedTables.some(table => 
            url.toString().includes(table)
          );
          
          // Allow GET requests after 1 second for frequently accessed tables, 3 seconds for others
          if (isReadOperation && ((isFrequentlyAccessedTable && timeSinceRequest > 1000) || timeSinceRequest > 3000)) {
            console.log(`Allowing repeated GET request after ${timeSinceRequest}ms: ${url}`);
          } else if (timeSinceRequest < 1000) {
            // For very rapid repeats (< 1s), reject unless it's a call_transcripts write operation
            if (isWriteOperation && url.toString().includes('call_transcripts')) {
              console.log(`Allowing write operation for call_transcripts despite recent request: ${url}`);
            } else if (isFrequentlyAccessedTable) {
              // For frequently accessed tables, log but don't reject
              console.log(`Merge duplicate request for ${url} - using previous result when ready`);
              
              // Return a promise that will resolve with the original request's result
              return new Promise<Response>((resolve) => {
                // Check every 100ms if the original request has completed
                const checkInterval = setInterval(() => {
                  const updatedRequest = requestCache.get(cacheKey);
                  if (updatedRequest && !updatedRequest.inProgress) {
                    clearInterval(checkInterval);
                    // Create a clone of the cached response
                    const clonedResponse = new Response(
                      JSON.stringify(updatedRequest.response || { data: [], error: null }), 
                      { 
                        status: 200, 
                        headers: { 'Content-Type': 'application/json' } 
                      }
                    );
                    resolve(clonedResponse);
                  }
                }, 100);
                
                // Set a timeout to prevent hanging if something goes wrong
                setTimeout(() => {
                  clearInterval(checkInterval);
                  const fallbackResponse = new Response(
                    JSON.stringify({ data: [], error: null }), 
                    { status: 200, headers: { 'Content-Type': 'application/json' } }
                  );
                  resolve(fallbackResponse);
                }, 5000);
              });
            } else {
              debouncedLog(`Skipping too-frequent request (${timeSinceRequest}ms) to: ${url}`);
              return new Promise<Response>((resolve, reject) => {
                setTimeout(() => {
                  reject(new Error('Duplicate request cancelled - too soon after previous request'));
                }, 100);
              });
            }
          }
        }
        
        // Log the request (but not duplicates)
        console.log(`Supabase request to: ${url}`);
        
        // Mark this request as in progress
        requestCache.set(cacheKey, {
          timestamp: Date.now(),
          inProgress: true,
          response: null
        });
        
        // Enhancement to prevent Content-Type not acceptable errors
        if (!options?.headers) {
          options.headers = {};
        }

        // Explicitly set needed headers for JSON operations when needed
        if (!options.headers['Content-Type'] && 
            (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') &&
            typeof options.body === 'string') {
          try {
            // Check if body looks like JSON
            JSON.parse(options.body);
            options.headers['Content-Type'] = 'application/json';
            console.log('Added missing Content-Type: application/json header');
          } catch (e) {
            // Not JSON, don't set content type, let browser determine it
          }
        }

        // Make sure Accept header is always set for GET requests to avoid text/plain responses
        if (options.method === 'GET' || !options.method) {
          options.headers['Accept'] = 'application/json';
        }
        
        const enhancedOptions = {
          ...options,
          headers: {
            ...options.headers,
            'apikey': SUPABASE_PUBLISHABLE_KEY,
            'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
          }
        };
        
        // Check if we're offline before attempting the request
        if (errorHandler.isOffline) {
          console.warn(`Offline: Skipping request to ${url}`);
          
          // Store operation in queue for later execution
          return new Promise<Response>((resolve, reject) => {
            offlineQueue.push({
              operation: `${options?.method || 'GET'} ${url}`,
              callback: async () => {
                try {
                  const response = await fetch(url, enhancedOptions);
                  resolve(response);
                } catch (error) {
                  reject(error);
                }
              }
            });
            
            throw new Error('You are currently offline - operation queued');
          });
        }
        
        try {
          // Implement retries with exponential backoff
          const maxRetries = 3;
          let retryCount = 0;
          let lastError;
          
          while (retryCount < maxRetries) {
            try {
              const response = await fetch(url, enhancedOptions);
              
              // Log successful requests
              if (response.ok) {
                console.log(`Supabase request successful: ${url}`);
                
                // Mark request as completed and store response data
                const responseClone = response.clone();
                
                try {
                  // Read the JSON data once and store it in the cache
                  const jsonData = await responseClone.json();
                  
                  if (requestCache.has(cacheKey)) {
                    requestCache.set(cacheKey, {
                      timestamp: Date.now(),
                      inProgress: false,
                      response: {
                        data: jsonData,
                        error: null
                      }
                    });
                  }
                } catch (jsonError) {
                  console.warn('Failed to parse response as JSON:', jsonError);
                  // Still mark as not in progress even if JSON parsing fails
                  if (requestCache.has(cacheKey)) {
                    requestCache.set(cacheKey, {
                      timestamp: Date.now(),
                      inProgress: false,
                      response: null
                    });
                  }
                }
                
                if (!isSupabaseConnected) {
                  isSupabaseConnected = true;
                  connectionAttempts = 0; // Reset connection attempts on success
                  // Dispatch a connection restored event
                  window.dispatchEvent(new CustomEvent('supabase-connection-restored'));
                }
                return response;
              } else {
                console.warn(`Supabase request failed with status ${response.status}: ${url}`);
                // Only log the first few characters of the response for debugging
                const responseText = await response.clone().text();
                console.warn(`Response preview: ${responseText.substring(0, 200)}${responseText.length > 200 ? '...' : ''}`);
                
                // Handle invalid UUID format errors specifically
                if (responseText.includes("invalid input syntax for type uuid")) {
                  errorHandler.handleError({
                    message: 'Data format error',
                    technical: `UUID format error: ${responseText}`,
                    severity: 'error',
                    code: 'UUID_FORMAT_ERROR'
                  });
                  // Don't retry UUID errors as they require code fixes
                  throw new Error(`UUID format error: ${responseText}`);
                }
                
                // Handle specific error status codes
                if (response.status === 401 || response.status === 403) {
                  errorHandler.handleError({
                    message: 'Authentication error',
                    technical: `Status ${response.status}: ${responseText}`,
                    severity: 'warning',
                    code: 'AUTH_ERROR'
                  });
                } else if (response.status >= 500) {
                  errorHandler.handleError({
                    message: 'Server error',
                    technical: `Status ${response.status}: ${responseText}`,
                    severity: 'error',
                    code: 'SERVER_ERROR'
                  });
                }
                
                // If we get a 429 (too many requests), wait longer before retrying
                if (response.status === 429) {
                  await new Promise(resolve => setTimeout(resolve, 2000 * (retryCount + 1)));
                  retryCount++;
                  continue;
                }
                
                // Return the error response to be handled by the caller
                return response;
              }
            } catch (error) {
              console.error(`Supabase fetch attempt ${retryCount + 1} failed:`, error);
              lastError = error;
              isSupabaseConnected = false;
              
              // Check if error is a CORS error
              const errorMsg = error instanceof Error ? error.message : String(error);
              if (errorMsg.includes('CORS') || errorMsg.includes('cross-origin')) {
                console.warn('CORS error detected. Adding no-cors mode for retry');
                // Try again with no-cors mode
                try {
                  // Note: no-cors means we can't read the response content
                  await fetch(url, {
                    ...enhancedOptions,
                    mode: 'no-cors',
                    headers: {
                      ...enhancedOptions.headers,
                      'apikey': SUPABASE_PUBLISHABLE_KEY,
                      'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
                    }
                  });
                  
                  // If we get here without an error, we likely have some access
                  isSupabaseConnected = true;
                  window.dispatchEvent(new CustomEvent('supabase-connection-restored'));
                  
                  // However, we still need to return a valid response for the original request
                  break; // Exit retry loop
                } catch (corsError) {
                  console.error('Still failed with no-cors mode:', corsError);
                }
              }
              
              // Dispatch a connection lost event
              window.dispatchEvent(new CustomEvent('supabase-connection-lost', { 
                detail: { error, retryCount } 
              }));
              
              // Exponential backoff
              const delay = Math.min(1000 * Math.pow(2, retryCount), 10000);
              await new Promise(resolve => setTimeout(resolve, delay));
              retryCount++;
            }
          }
          
          // If we've exhausted retries, throw the last error
          connectionAttempts++; // Increment overall connection attempts
          
          // If we've exceeded max attempts, show a more permanent error
          if (connectionAttempts >= MAX_CONNECTION_ATTEMPTS) {
            errorHandler.handleError({
              message: 'Unable to connect to the server',
              technical: lastError instanceof Error ? lastError.message : String(lastError),
              severity: 'critical',
              code: 'CONNECTION_FAILED',
              actionable: true,
              retry: async () => {
                connectionAttempts = 0; // Reset counter when user manually retries
                return checkSupabaseConnection();
              }
            });
          }
          
          // Create a fallback response to satisfy the Response type requirement
          return new Response(JSON.stringify({ error: 'Connection failed after retries' }), {
            status: 503,
            headers: { 'Content-Type': 'application/json' }
          });
        } catch (error) {
          console.error(`Supabase request failed after retries: ${url}`, error);
          
          errorHandler.handleError({
            message: 'Database connection failed',
            technical: error instanceof Error ? error.message : String(error),
            severity: 'error',
            code: 'SUPABASE_CONNECTION',
            actionable: true,
            retry: async () => {
              // Try to ping the database again
              return checkSupabaseConnection();
            }
          });
          
          // Create a fallback response to satisfy the Response type requirement
          return new Response(JSON.stringify({ error: 'Network request failed' }), {
            status: 503,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }
    },
    db: {
      schema: 'public',
    },
  }
);

// Process queued operations when we're back online
const processOfflineQueue = async () => {
  if (offlineQueue.length === 0) return;
  
  console.log(`Processing ${offlineQueue.length} queued operations`);
  toast.info(`Syncing ${offlineQueue.length} offline changes...`);
  
  // Take a copy of the queue and clear it
  const queueToProcess = [...offlineQueue];
  offlineQueue.length = 0;
  
  let successCount = 0;
  let failureCount = 0;
  
  for (const item of queueToProcess) {
    try {
      console.log(`Processing queued operation: ${item.operation}`);
      await item.callback();
      successCount++;
    } catch (error) {
      console.error(`Failed to process queued operation: ${item.operation}`, error);
      failureCount++;
      // Re-queue for next time if it's a temporary failure
      if (!(error instanceof Error) || !error.message.includes('UUID format error')) {
        offlineQueue.push(item);
      }
    }
  }
  
  if (successCount > 0) {
    toast.success(`${successCount} offline changes synced successfully.`);
  }
  
  if (failureCount > 0) {
    toast.error(`Failed to sync ${failureCount} changes. Will retry later.`);
  }
};

// Listen for online/offline events
if (typeof window !== 'undefined') {
  // Track last connection status for debouncing rapid changes
  let lastConnectionStatus = isSupabaseConnected;
  let connectionStatusTimeout: ReturnType<typeof setTimeout> | null = null;

  // Debounced function to update connection status
  const updateConnectionStatus = (online: boolean) => {
    // Don't set the same status twice and debounce rapid changes
    if (online === lastConnectionStatus) {
      return;
    }
    
    // Cancel any pending status changes
    if (connectionStatusTimeout) {
      clearTimeout(connectionStatusTimeout);
    }
    
    // Set a timeout to allow for fast toggling to settle
    connectionStatusTimeout = setTimeout(() => {
      isSupabaseConnected = online;
      lastConnectionStatus = online;
      
      console.log(`Connection status updated: ${online ? 'online' : 'offline'}`);
      
      // Only notify if status actually changed
      if (online) {
        errorHandler.setOffline(false);
        // Process any queued operations when coming back online
        processOfflineQueue();
      } else {
        errorHandler.setOffline(true);
      }
      
      connectionStatusTimeout = null;
    }, 500); // 500ms debounce
  };
  
  // Listen for connection status events with the debounced handler
  window.addEventListener('supabase-connection-restored', () => {
    updateConnectionStatus(true);
  });
  
  window.addEventListener('supabase-connection-lost', () => {
    updateConnectionStatus(false);
  });

  // Don't block the app initialization, run connection check asynchronously
  setTimeout(() => {
    checkSupabaseConnection();
  }, 1000);
}

// Connection checker
export const checkSupabaseConnection = async (): Promise<boolean> => {
  try {
    // Create a fresh client for this check to avoid cached responses
    const { data, error } = await supabase.from('calls').select('*').limit(1);
    
    if (error) {
      // The error variable contains a lot of useful details, but don't access its message
      console.error('Supabase connection check failed:', {
        status: error.code,
        hint: error.hint,
        details: error.details
      });
      
      errorHandler.setOffline(true);
      toast.error('Database connection failed', {
        description: 'Could not connect to the database.'
      });
      return false;
    }
    
    // Successfully connected
    console.log('Supabase connection check successful');
    errorHandler.setOffline(false);
    
    // Only show a success toast if we were previously offline
    if (errorHandler.isOffline) {
      toast.success('Database connection restored', {
        description: 'You can now resume using all features.'
      });
    }
    
    return true;
  } catch (error) {
    // Error object may be safe to use directly here since we're not reading an already consumed response
    console.error('Supabase connection check failed:', error);
    errorHandler.setOffline(true);
    toast.error('Database connection failed', {
      description: error instanceof Error ? error.message : 'Could not connect to the database.'
    });
    return false;
  }
};

// Check connection status
export const isConnected = () => isSupabaseConnected;

// Generate a proper anonymous user ID using the uuid library
export const generateAnonymousUserId = () => {
  // Generate a unique identifier using UUID v4
  const anonymousId = `anonymous-${uuidv4()}`;
  console.log('Generated anonymous user ID:', anonymousId);
  return anonymousId;
};

// Preload an audio file from Supabase Storage
export const preloadAudioFile = async (bucketName: string, filePath: string): Promise<Blob | null> => {
  try {
    console.log(`Preloading audio file from Supabase Storage: ${bucketName}/${filePath}`);
    
    // First check if we're online
    if (errorHandler.isOffline) {
      console.warn('Cannot preload audio file: offline');
      throw new Error('Unable to download audio file: you are offline');
    }
    
    // Create signed URL for faster access
    const { data: signedURLData, error: signedURLError } = await supabase
      .storage
      .from(bucketName)
      .createSignedUrl(filePath, 60); // 60 seconds expiry
    
    if (signedURLError || !signedURLData?.signedUrl) {
      console.error('Error creating signed URL:', signedURLError);
      
      // Fall back to public URL
      const { data: publicURLData } = await supabase
        .storage
        .from(bucketName)
        .getPublicUrl(filePath);
      
      if (!publicURLData?.publicUrl) {
        throw new Error(`Failed to get URL for file: ${filePath}`);
      }
      
      console.log('Using public URL as fallback');
      const response = await fetch(publicURLData.publicUrl);
      if (!response.ok) {
        throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);
      }
      
      return await response.blob();
    }
    
    // Use the signed URL for faster downloads
    console.log('Using signed URL for faster download');
    const response = await fetch(signedURLData.signedUrl);
    if (!response.ok) {
      throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);
    }
    
    const blob = await response.blob();
    console.log(`Successfully downloaded ${blob.size} bytes`);
    return blob;
  } catch (error) {
    console.error('Error preloading audio file:', error);
    return null;
  }
};
